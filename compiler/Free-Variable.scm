;;;
;;; Free-Variable (Auxiliary Function)
;;;

(define-module Free-Variable
  (use srfi-1)
  (use util.match)
  (require "./Basic-Utility")
  (require "./Set")
  (import Basic-Utility)
  (import Set)
  (export Free-Variable
          ))
(select-module Free-Variable)

(define filter-variable
  (lambda (ls)
    (filter var? ls)))

(define free-variable
  (lambda (exp)
    (match exp
      (() empty-set)
      ((? boolean? bool) empty-set)
      ((? integer? int) empty-set)
      ((? float? float) empty-set)
      ((? var? var) (singleton var))
      (('Cons A W c)
       (let ((fv-A (filter-variable A))
             (fv-c (free-variable c)))
         (set-union fv-A (set-diff fv-c W))))
      (('Vector A W c)
       (let ((fv-A (filter-variable A))
             (fv-c (free-variable c)))
         (set-union fv-A (set-diff fv-c W))))
      (('Stack s A W c)
       (let ((fv-s (filter-variable `(,s)))
             (fv-A (filter-variable A))
             (fv-c (free-variable c)))
         (set-union fv-s fv-A (set-diff fv-c W))))
      (('Select i r W c)
       (let ((fv-i (free-variable i))
             (fv-r (free-variable r))
             (fv-c (free-variable c)))
         (set-union fv-i fv-r (set-diff fv-c W))))
      (('Alloc i v W c)
       (let ((fv-i (free-variable i))
             (fv-v (free-variable v))
             (fv-c (free-variable c)))
         (set-union fv-i fv-v (set-diff fv-c W))))
      (('Put i r v () c)
       (let* ((fv-i (free-variable i))
              (fv-r (free-variable r))
              (fv-v (free-variable v))
              (fv-c (free-variable c)))
         (set-union fv-i fv-r fv-v fv-c)))
      (('Offset i r W c)
       (let ((fv-i (free-variable i))
             (fv-r (free-variable r))
             (fv-c (free-variable c)))
         (set-union fv-i fv-r (set-diff fv-c W))))
      (('Primop i A W c)
       (let ((fv-A (filter-variable A))
             (fv-c (free-variable c)))
         (set-union fv-A (set-diff fv-c W))))
      (('If t tc fc)
       (let ((fv-t (free-variable t))
             (fv-tc (free-variable tc))
             (fv-fc (free-variable fc)))
         (set-union fv-t fv-tc fv-fc)))
      (('Fix B A)
       (let* ((fs (map car B))
              (fv-B (fold set-union empty-set
                          (map (match-lambda
                                ((_ V C)
                                 (let ((fv-V (filter-variable V))
                                       (fv-C (free-variable C)))
                                   (set-diff fv-C fs fv-V))))
                               B)))
              (fv-A (set-diff (free-variable A) fs)))
         (set-union fv-B (set-diff fv-A fs))))
      (('Fix2 B A)
       (let* ((fs (map car B))
              (fv-B (fold set-union empty-set
                          (map (match-lambda
                                ((_ V C)
                                 (let ((fv-V (filter-variable V))
                                       (fv-C (free-variable C)))
                                   (set-diff fv-C fs fv-V))))
                               B)))
              (fv-A (set-diff (free-variable A) fs)))
         (set-union fv-B (set-diff fv-A fs))))
      (('Apply f A)
       (let ((fv-f (free-variable f))
             (fv-A (filter-variable A)))
         (set-union fv-f fv-A)))
      (('Set v W c)
       (let ((fv-v (free-variable v))
             (fv-c (free-variable c)))
         (set-union fv-v (set-diff fv-c W))))
      (('Global-Set v W c)
       (let ((fv-v (free-variable v))
             (fv-c (free-variable c)))
         (set-union fv-v (set-diff fv-c W))))
      (else (errorf "~s : no match expressin : ~s\n" "free-variable" exp)))))

(define Free-Variable free-variable)

(provide "Free-Variable")