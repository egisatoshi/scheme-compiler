;;;
;;; Propagation (Auxiliary Function)
;;;

(define-module Propagation
  (use srfi-1)
  (use srfi-11)
  (use util.match)
  (require "./Basic-Utility")
  (require "./CPS-Language")
  (import Basic-Utility)
  (import CPS-Language)
  (export Propagate
          Propagate-Count
          ))
(select-module Propagation)

(define propagate
  (lambda (proc exp . extargs)
    (match exp
      (() ())
      ((? boolean? bool) bool)
      ((? integer? int) int)
      ((? float? float) float)
      ((? var? var) var)
      (('Cons A W c)
       (let ((new-c (apply proc (cons c extargs))))
         `(Cons ,A ,W ,new-c)))
      (('Vector A W c)
       (let ((new-c (apply proc (cons c extargs))))
         `(Vector ,A ,W ,new-c)))
      (('Stack s A W c)
       (let ((new-c (apply proc (cons c extargs))))
         `(Stack ,s ,A ,W ,new-c)))
      (('Select i r W c)
       (let ((new-c (apply proc (cons c extargs))))
         `(Select ,i ,r ,W ,new-c)))
      (('Alloc i v W c)
       (let ((new-c (apply proc (cons c extargs))))
         `(Alloc ,i ,v ,W ,new-c)))
      (('Put i r v () c)
       (let ((new-c (apply proc (cons c extargs))))
         `(Put ,i ,r ,v () ,new-c)))
      (('Offset i r W c)
       (let ((new-c (apply proc (cons c extargs))))
         `(Offset ,i ,r ,W ,new-c)))
      (('Primop i A W c)
       (let ((new-c (apply proc (cons c extargs))))
         `(Primop ,i ,A ,W ,new-c)))
      (('If t tc fc)
       (let ((new-tc (apply proc (cons tc extargs)))
             (new-fc (apply proc (cons fc extargs))))
         `(If ,t ,new-tc ,new-fc)))
      (('Fix B A)
       (let ((new-B (map (match-lambda
                          ((f V C) `(,f ,V ,(apply proc (cons C extargs)))))
                         B))
             (new-A (apply proc (cons A extargs))))
         `(Fix ,new-B ,new-A)))
      (('Fix2 B A)
       (let ((new-B (map (match-lambda
                          ((f V C) `(,f ,V ,(apply proc (cons C extargs)))))
                         B))
             (new-A (apply proc (cons A extargs))))
         `(Fix2 ,new-B ,new-A)))
      (('Apply f A)
       `(Apply ,f ,A))
      (('Set v W c)
       (let ((new-c (apply proc (cons c extargs))))
         `(Set ,v ,W ,new-c)))
      (else (errorf "~s : no match expressin : ~s\n" proc exp)))))

(define Propagate
  (lambda (proc program . extargs)
    (apply propagate (append `(,proc ,program) extargs))))

(define propagate-count
  (lambda (proc exp . extargs)
    (match exp
      (() ())
      ((? boolean? bool) 0)
      ((? integer? int) 0)
      ((? float? float) 0)
      ((? var? var) 0)
      (('Cons _ _ c)
       (apply proc (cons c extargs)))
      (('Vector _ _ c)
       (apply proc (cons c extargs)))
      (('Stack _ _ _ c)
       (apply proc (cons c extargs)))
      (('Select _ _ _ c)
       (apply proc (cons c extargs)))
      (('Alloc _ _ _ c)
       (apply proc (cons c extargs)))
      (('Put _ _ _ _ c)
       (apply proc (cons c extargs)))
      (('Offset _ _ _ c)
       (apply proc (cons c extargs)))
      (('Primop _ _ _ c)
       (apply proc (cons c extargs)))
      (('If _ tc fc)
       (+ (apply proc (cons tc extargs))
          (apply proc (cons fc extargs))))
      (('Fix B A)
       (let ((count-B (apply + (map (match-lambda
                                     ((_ _ C) (apply proc (cons C extargs))))
                                    B)))
             (count-A (apply proc (cons A extargs))))
         (+ count-B count-A)))
      (('Fix2 B A)
       (let ((count-B (apply + (map (match-lambda
                                     ((_ _ C) (apply proc (cons C extargs))))
                                    B)))
             (count-A (apply proc (cons A extargs))))
         (+ count-B count-A)))
      (('Apply _ _) 0)
      (('Set _ _W c)
       (apply proc (cons c extargs)))
      (else (errorf "~s : no match expressin : ~s\n" proc exp)))))

(define Propagate-Count
  (lambda (proc program . extargs)
    (apply propagate-count (append `(,proc ,program) extargs))))

(provide "Propagation")